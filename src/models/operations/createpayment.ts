/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";

/**
 * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
 *
 * @remarks
 *
 * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
 */
export type Amount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The price of a single item including VAT.
 *
 * @remarks
 *
 * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
 *
 * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
 *
 * The unit price can be zero in case of free items.
 */
export type UnitPrice = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount type.
 */
export type DiscountAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The total amount of the line, including VAT and discounts.
 *
 * @remarks
 *
 * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
 *
 * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
 */
export type TotalAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
 *
 * @remarks
 *
 * Any deviations from this will result in an error.
 *
 * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of `SEK 100.00 × (25 / 125) = SEK 20.00`.
 */
export type VatAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

export type Lines = {
  /**
   * The type of product purchased. For example, a physical or a digital product.
   *
   * @remarks
   *
   * Possible values: `physical` `digital` `shipping_fee` `discount` `store_credit` `gift_card` `surcharge` (default: `physical`)
   */
  type?: string | undefined;
  /**
   * A description of the line item. For example *LEGO 4440 Forest Police Station*.
   */
  description: string;
  /**
   * The number of items.
   */
  quantity: number;
  /**
   * The unit for the quantity. For example *pcs*, *kg*, or *cm*.
   */
  quantityUnit?: string | undefined;
  /**
   * The price of a single item including VAT.
   *
   * @remarks
   *
   * For example: `{"currency":"EUR", "value":"89.00"}` if the box of LEGO costs €89.00 each.
   *
   * For types `discount`, `store_credit`, and `gift_card`, the unit price must be negative.
   *
   * The unit price can be zero in case of free items.
   */
  unitPrice: UnitPrice;
  /**
   * Any line-specific discounts, as a positive amount. Not relevant if the line itself is already a discount type.
   */
  discountAmount?: DiscountAmount | undefined;
  /**
   * The total amount of the line, including VAT and discounts.
   *
   * @remarks
   *
   * Should match the following formula: `(unitPrice × quantity) - discountAmount`.
   *
   * The sum of all `totalAmount` values of all order lines should be equal to the full payment amount.
   */
  totalAmount: TotalAmount;
  /**
   * The VAT rate applied to the line, for example `21.00` for 21%. The vatRate should be passed as a string and not as a float, to ensure the correct number of decimals are passed.
   */
  vatRate?: string | undefined;
  /**
   * The amount of value-added tax on the line. The `totalAmount` field includes VAT, so the `vatAmount` can be calculated with the formula `totalAmount × (vatRate / (100 + vatRate))`.
   *
   * @remarks
   *
   * Any deviations from this will result in an error.
   *
   * For example, for a `totalAmount` of SEK 100.00 with a 25.00% VAT rate, we expect a VAT amount of `SEK 100.00 × (25 / 125) = SEK 20.00`.
   */
  vatAmount?: VatAmount | undefined;
  /**
   * The SKU, EAN, ISBN or UPC of the product sold.
   */
  sku?: string | undefined;
  /**
   * A link pointing to an image of the product sold.
   */
  imageUrl?: string | undefined;
  /**
   * A link pointing to the product page in your web shop of the product sold.
   */
  productUrl?: string | undefined;
};

/**
 * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
 */
export type BillingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only numbers.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only numbers.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   */
  streetAndNumber: string;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   */
  postalCode?: string | undefined;
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  city: string;
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   */
  country: string;
};

/**
 * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
 */
export type ShippingAddress = {
  /**
   * The title of the person, for example *Mr.* or *Mrs.*.
   */
  title?: string | undefined;
  /**
   * The given name (first name) of the person should be at least two characters and cannot contain only numbers.
   */
  givenName?: string | undefined;
  /**
   * The given family name (surname) of the person should be at least two characters and cannot contain only numbers.
   */
  familyName?: string | undefined;
  /**
   * The name of the organization, in case the addressee is an organization.
   */
  organizationName?: string | undefined;
  /**
   * A street and street number.
   */
  streetAndNumber: string;
  /**
   * Any additional addressing details, for example an apartment number.
   */
  streetAdditional?: string | undefined;
  /**
   * A postal code. This field may be required if the provided country has a postal code system.
   */
  postalCode?: string | undefined;
  email?: string | undefined;
  /**
   * If provided, it must be in the [E.164](https://en.wikipedia.org/wiki/E.164) format. For example: +31208202070.
   */
  phone?: string | undefined;
  city: string;
  region?: string | undefined;
  /**
   * A country code in [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
   */
  country: string;
};

/**
 * The fee that you wish to charge.
 *
 * @remarks
 *
 * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge a €0.99 fee on a €1.00 payment.
 */
export type CreatePaymentAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
 *
 * @remarks
 *
 * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
 *
 * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
 */
export type ApplicationFee = {
  /**
   * The fee that you wish to charge.
   *
   * @remarks
   *
   * Be careful to leave enough space for Mollie's own fees to be deducted as well. For example, you cannot charge a €0.99 fee on a €1.00 payment.
   */
  amount?: CreatePaymentAmount | undefined;
  /**
   * The description of the application fee. This will appear on settlement reports towards both you and the connected merchant.
   */
  description?: string | undefined;
};

/**
 * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
 */
export type CreatePaymentPaymentsAPIAmount = {
  /**
   * A three-character ISO 4217 currency code.
   */
  currency: string;
  /**
   * A string containing an exact monetary amount in the given currency.
   */
  value: string;
};

/**
 * The destination of this portion of the payment.
 */
export type Destination = {
  /**
   * The type of destination. Currently only the destination type `organization` is supported.
   *
   * @remarks
   *
   * Possible values: `organization`
   */
  type?: string | undefined;
  /**
   * Required for destination type `organization`. The ID of the connected organization the funds should be routed to.
   */
  organizationId?: string | undefined;
};

export type Routing = {
  /**
   * The portion of the total payment amount being routed. Currently only `EUR` payments can be routed.
   */
  amount?: CreatePaymentPaymentsAPIAmount | undefined;
  /**
   * The destination of this portion of the payment.
   */
  destination?: Destination | undefined;
  /**
   * Optionally, schedule this portion of the payment to be transferred to its destination on a later date. The date must be given in `YYYY-MM-DD` format.
   *
   * @remarks
   *
   * If no date is given, the funds become available to the connected merchant as soon as the payment succeeds.
   */
  releaseDate?: string | undefined;
};

export type CreatePaymentRequestBody = {
  /**
   * The description of the payment. This will be shown to your customer on their card or bank statement when possible. We truncate the description automatically according to the limits of the used payment method. The description is also visible in any exports you generate.
   *
   * @remarks
   *
   * We recommend you use a unique identifier so that you can always link the payment to the order in your back office. This is particularly useful for bookkeeping.
   *
   * The maximum length of the description field differs per payment method, with the absolute maximum being 255 characters. The API will not reject strings longer than the maximum length but it will truncate them to fit.
   */
  description: string;
  /**
   * The amount that you want to charge, e.g. `{currency:"EUR", value:"1000.00"}` if you would want to charge €1000.00.
   *
   * @remarks
   *
   * You can find the minimum and maximum amounts per payment method in our help center. Additionally, they can be retrieved using the Get method endpoint.
   */
  amount: Amount;
  /**
   * The URL your customer will be redirected to after the payment process.
   *
   * @remarks
   *
   * It could make sense for the redirectUrl to contain a unique identifier – like your order ID – so you can show the right page referencing the order when your customer returns.
   *
   * The parameter is normally required, but can be omitted for recurring payments (`sequenceType: recurring`) and for Apple Pay payments with an `applePayPaymentToken`.
   */
  redirectUrl: string | null;
  /**
   * The URL your customer will be redirected to when the customer explicitly cancels the payment. If this URL is not provided, the customer will be redirected to the `redirectUrl` instead — see above.
   *
   * @remarks
   *
   * Mollie will always give you status updates via webhooks, including for the canceled status. This parameter is therefore entirely optional, but can be useful when implementing a dedicated customer-facing flow to handle payment cancellations.
   */
  cancelUrl?: string | null | undefined;
  /**
   * The webhook URL where we will send payment status updates to.
   *
   * @remarks
   *
   * The webhookUrl is optional, but without a webhook you will miss out on important status changes to your payment.
   *
   * The webhookUrl must be reachable from Mollie's point of view, so you cannot use `localhost`. If you want to use webhook during development on `localhost`, you must use a tool like ngrok to have the webhooks delivered to your local machine.
   */
  webhookUrl?: string | null | undefined;
  /**
   * Optionally provide the order lines for the payment. Each line contains details such as a description of the item ordered and its price.
   *
   * @remarks
   *
   * All lines must have the same currency as the payment.
   */
  lines?: Array<Lines> | null | undefined;
  /**
   * The customer's billing address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
   */
  billingAddress?: BillingAddress | undefined;
  /**
   * The customer's shipping address details. We advise to provide these details to improve fraud protection and conversion. This is particularly relevant for card payments.
   */
  shippingAddress?: ShippingAddress | undefined;
  /**
   * Allows you to preset the language to be used in the hosted payment pages shown to the customer. Setting a locale is highly recommended and will greatly improve your conversion rate. When this parameter is omitted the browser language will be used instead if supported by the payment method. You can provide any `xx_XX` format ISO 15897 locale, but our hosted payment pages currently only support the specified languages.
   *
   * @remarks
   *
   * For bank transfer payments specifically, the locale will determine the target bank account the customer has to transfer the money to. We have dedicated bank accounts for Belgium, Germany, and The Netherlands. Having the customer use a local bank account greatly increases the conversion and speed of payment.
   *
   * Possible values: `en_US` `en_GB` `nl_NL` `nl_BE` `fr_FR` `fr_BE` `de_DE` `de_AT` `de_CH` `es_ES` `ca_ES` `pt_PT` `it_IT` `nb_NO` `sv_SE` `fi_FI` `da_DK` `is_IS` `hu_HU` `pl_PL` `lv_LV` `lt_LT`
   */
  locale?: string | null | undefined;
  /**
   * Normally, a payment method screen is shown. However, when using this parameter, you can choose a specific payment method and your customer will skip the selection screen and is sent directly to the chosen payment method. The parameter enables you to fully integrate the payment method selection into your website.
   *
   * @remarks
   *
   * You can also specify the methods in an array. By doing so we will still show the payment method selection screen but will only show the methods specified in the array. For example, you can use this functionality to only show payment methods from a specific country to your customer `['bancontact', 'belfius']`.
   *
   * Possible values: `applepay` `bancontact` `banktransfer` `belfius` `creditcard` `directdebit` `eps` `giftcard` `giropay` `ideal` `kbc` `mybank` `paypal` `paysafecard` `przelewy24` `sofort`
   */
  method?: string | null | undefined;
  /**
   * **Only relevant for iDEAL, KBC/CBC, gift card, and voucher payments.**
   *
   * @remarks
   *
   * **⚠️ With the introduction of iDEAL 2 in 2025, this field will be ignored for iDEAL payments. For more information on the migration, refer to our [help center](https://help.mollie.com/hc/articles/19100313768338-iDEAL-2-0).**
   *
   * Some payment methods are a network of connected banks or card issuers. In these cases, after selecting the payment method, the customer may still need to select the appropriate issuer before the payment can proceed.
   *
   * We provide hosted issuer selection screens, but these screens can be skipped by providing the `issuer` via the API up front.
   *
   * The full list of issuers for a specific method can be retrieved via the Methods API by using the optional `issuers` include.
   *
   * A valid issuer for iDEAL is for example `ideal_INGBNL2A` (for ING Bank).
   */
  issuer?: string | null | undefined;
  /**
   * For digital goods in most jurisdictions, you must apply the VAT rate from your customer's country. Choose the VAT rates you have used for the order to ensure your customer's country matches the VAT country.
   *
   * @remarks
   *
   * Use this parameter to restrict the payment methods available to your customer to those from a single country.
   *
   * If available, the credit card method will still be offered, but only cards from the allowed country are accepted.
   *
   * The field expects a country code in ISO 3166-1 alpha-2 format, for example `NL`.
   */
  restrictPaymentMethodsToCountry?: string | null | undefined;
  /**
   * Provide any data you like, for example a string or a JSON object. We will save the data alongside the entity. Whenever you fetch the entity with our API, we will also include the metadata. You can use up to approximately 1kB.
   */
  metadata?: string | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * By default, the customer's card or bank account is immediately charged when they complete the payment.
   *
   * Some payment methods also allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
   *
   * To enable this way of working, set the capture mode to `manual` and capture the payment manually using the [Create capture endpoint](create-capture).
   *
   * Possible values: `automatic` `manual`
   */
  captureMode?: string | null | undefined;
  /**
   * **Only relevant if you wish to manage authorization and capturing separately.**
   *
   * @remarks
   *
   * Some payment methods allow placing a hold on the card or bank account. This hold or 'authorization' can then at a later point either be 'captured' or canceled.
   *
   * By default, we charge the customer's card or bank account immediately when they complete the payment. If you set a capture delay however, we will delay the automatic capturing of the payment for the specified amount of time. For example `8 hours` or `2 days`.
   *
   * To schedule an automatic capture, the `captureMode` must be set to `automatic`.
   *
   * The maximum delay is 7 days (168 hours).
   *
   * Possible values: `...hours` `... days`
   */
  captureDelay?: string | null | undefined;
  /**
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
   *
   * @remarks
   *
   * If you use OAuth to create payments on a connected merchant's account, you can charge a fee using this `applicationFee` parameter. If the payment succeeds, the fee will be deducted from the merchant's balance and sent to your own account balance.
   *
   * If instead you want to split a payment on your own account between yourself and a connected merchant, refer to the `routing` parameter.
   */
  applicationFee?: ApplicationFee | undefined;
  /**
   * *This functionality is not enabled by default. Reach out to our partner management team if you wish to use it.*
   *
   * @remarks
   *
   * With Mollie Connect you can charge fees on payments that your app is processing on behalf of other Mollie merchants.
   *
   * If you create payments on your own account that you want to split between yourself and one or more connected merchants, you can use this `routing` parameter to route the payment accordingly.
   *
   * The `routing` parameter should contain an array of objects, with each object describing the destination for a specific portion of the payment.
   *
   * It is not necessary to indicate in the array which portion goes to yourself. After all portions of the total payment amount have been routed, the amount left will be routed to the current organization automatically.
   *
   * If instead you use OAuth to create payments on a connected merchant's account, refer to the `applicationFee` parameter.
   */
  routing?: Array<Routing> | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * Indicate which part of a recurring sequence this payment is for.
   *
   * Recurring payments can only take place if a mandate is available. A common way to establish such a mandate is through a `first` payment. With a `first` payment, the customer agrees to automatic recurring charges taking place on their account in the future.
   *
   * If set to `recurring`, the customer's card is charged automatically.
   *
   * Defaults to `oneoff`, which is a regular non-recurring payment.
   *
   * For PayPal payments, recurring is only possible if your connected PayPal account allows it. You can call our [Methods API](list-methods) with parameter `sequenceType: first` to discover which payment methods on your account are set up correctly for recurring payments.
   *
   * Possible values: `oneoff` `first` `recurring`
   */
  sequenceType?: string | null | undefined;
  /**
   * **Only relevant for recurring payments.**
   *
   * @remarks
   *
   * When creating recurring payments, the ID of a specific [mandate](get-mandate) can be supplied to indicate which of the customer's accounts should be credited.
   */
  mandateId?: string | null | undefined;
  /**
   * The ID of the [customer](get-customer) the payment is being created for. This is used primarily for recurring payments, but can also be used on regular payments to enable single-click payments.
   *
   * @remarks
   *
   * If `sequenceType` is set to `recurring`, this field is required.
   */
  customerId?: string | null | undefined;
  /**
   * The identifier referring to the [profile](get-profile) this entity belongs to.
   *
   * @remarks
   *
   * Most API credentials are linked to a single profile. In these cases the `profileId` can be omitted in the creation request. For organization-level credentials such as OAuth access tokens however, the `profileId` parameter is required.
   */
  profileId?: string | null | undefined;
  /**
   * Whether to create the entity in test mode or live mode.
   *
   * @remarks
   *
   * Most API credentials are specifically created for either live mode or test mode, in which case this parameter can be omitted. For organization-level credentials such as OAuth access tokens, you can enable test mode by setting `testmode` to `true`.
   */
  testmode?: boolean | null | undefined;
};

export type CreatePaymentRequest = {
  /**
   * This endpoint allows you to include additional information via the `include` query string parameter.
   *
   * @remarks
   *
   * * `details.qrCode`: Include a QR code object. Only available for iDEAL, Bancontact and bank transfer payments.
   */
  include?: string | null | undefined;
  requestBody?: CreatePaymentRequestBody | undefined;
};

/** @internal */
export const Amount$inboundSchema: z.ZodType<Amount, z.ZodTypeDef, unknown> = z
  .object({
    currency: z.string(),
    value: z.string(),
  });

/** @internal */
export type Amount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const Amount$outboundSchema: z.ZodType<
  Amount$Outbound,
  z.ZodTypeDef,
  Amount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Amount$ {
  /** @deprecated use `Amount$inboundSchema` instead. */
  export const inboundSchema = Amount$inboundSchema;
  /** @deprecated use `Amount$outboundSchema` instead. */
  export const outboundSchema = Amount$outboundSchema;
  /** @deprecated use `Amount$Outbound` instead. */
  export type Outbound = Amount$Outbound;
}

/** @internal */
export const UnitPrice$inboundSchema: z.ZodType<
  UnitPrice,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type UnitPrice$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const UnitPrice$outboundSchema: z.ZodType<
  UnitPrice$Outbound,
  z.ZodTypeDef,
  UnitPrice
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnitPrice$ {
  /** @deprecated use `UnitPrice$inboundSchema` instead. */
  export const inboundSchema = UnitPrice$inboundSchema;
  /** @deprecated use `UnitPrice$outboundSchema` instead. */
  export const outboundSchema = UnitPrice$outboundSchema;
  /** @deprecated use `UnitPrice$Outbound` instead. */
  export type Outbound = UnitPrice$Outbound;
}

/** @internal */
export const DiscountAmount$inboundSchema: z.ZodType<
  DiscountAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type DiscountAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const DiscountAmount$outboundSchema: z.ZodType<
  DiscountAmount$Outbound,
  z.ZodTypeDef,
  DiscountAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiscountAmount$ {
  /** @deprecated use `DiscountAmount$inboundSchema` instead. */
  export const inboundSchema = DiscountAmount$inboundSchema;
  /** @deprecated use `DiscountAmount$outboundSchema` instead. */
  export const outboundSchema = DiscountAmount$outboundSchema;
  /** @deprecated use `DiscountAmount$Outbound` instead. */
  export type Outbound = DiscountAmount$Outbound;
}

/** @internal */
export const TotalAmount$inboundSchema: z.ZodType<
  TotalAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type TotalAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const TotalAmount$outboundSchema: z.ZodType<
  TotalAmount$Outbound,
  z.ZodTypeDef,
  TotalAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TotalAmount$ {
  /** @deprecated use `TotalAmount$inboundSchema` instead. */
  export const inboundSchema = TotalAmount$inboundSchema;
  /** @deprecated use `TotalAmount$outboundSchema` instead. */
  export const outboundSchema = TotalAmount$outboundSchema;
  /** @deprecated use `TotalAmount$Outbound` instead. */
  export type Outbound = TotalAmount$Outbound;
}

/** @internal */
export const VatAmount$inboundSchema: z.ZodType<
  VatAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type VatAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const VatAmount$outboundSchema: z.ZodType<
  VatAmount$Outbound,
  z.ZodTypeDef,
  VatAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace VatAmount$ {
  /** @deprecated use `VatAmount$inboundSchema` instead. */
  export const inboundSchema = VatAmount$inboundSchema;
  /** @deprecated use `VatAmount$outboundSchema` instead. */
  export const outboundSchema = VatAmount$outboundSchema;
  /** @deprecated use `VatAmount$Outbound` instead. */
  export type Outbound = VatAmount$Outbound;
}

/** @internal */
export const Lines$inboundSchema: z.ZodType<Lines, z.ZodTypeDef, unknown> = z
  .object({
    type: z.string().optional(),
    description: z.string(),
    quantity: z.number().int(),
    quantityUnit: z.string().optional(),
    unitPrice: z.lazy(() => UnitPrice$inboundSchema),
    discountAmount: z.lazy(() => DiscountAmount$inboundSchema).optional(),
    totalAmount: z.lazy(() => TotalAmount$inboundSchema),
    vatRate: z.string().optional(),
    vatAmount: z.lazy(() => VatAmount$inboundSchema).optional(),
    sku: z.string().optional(),
    imageUrl: z.string().optional(),
    productUrl: z.string().optional(),
  });

/** @internal */
export type Lines$Outbound = {
  type?: string | undefined;
  description: string;
  quantity: number;
  quantityUnit?: string | undefined;
  unitPrice: UnitPrice$Outbound;
  discountAmount?: DiscountAmount$Outbound | undefined;
  totalAmount: TotalAmount$Outbound;
  vatRate?: string | undefined;
  vatAmount?: VatAmount$Outbound | undefined;
  sku?: string | undefined;
  imageUrl?: string | undefined;
  productUrl?: string | undefined;
};

/** @internal */
export const Lines$outboundSchema: z.ZodType<
  Lines$Outbound,
  z.ZodTypeDef,
  Lines
> = z.object({
  type: z.string().optional(),
  description: z.string(),
  quantity: z.number().int(),
  quantityUnit: z.string().optional(),
  unitPrice: z.lazy(() => UnitPrice$outboundSchema),
  discountAmount: z.lazy(() => DiscountAmount$outboundSchema).optional(),
  totalAmount: z.lazy(() => TotalAmount$outboundSchema),
  vatRate: z.string().optional(),
  vatAmount: z.lazy(() => VatAmount$outboundSchema).optional(),
  sku: z.string().optional(),
  imageUrl: z.string().optional(),
  productUrl: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Lines$ {
  /** @deprecated use `Lines$inboundSchema` instead. */
  export const inboundSchema = Lines$inboundSchema;
  /** @deprecated use `Lines$outboundSchema` instead. */
  export const outboundSchema = Lines$outboundSchema;
  /** @deprecated use `Lines$Outbound` instead. */
  export type Outbound = Lines$Outbound;
}

/** @internal */
export const BillingAddress$inboundSchema: z.ZodType<
  BillingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string(),
  region: z.string().optional(),
  country: z.string(),
});

/** @internal */
export type BillingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber: string;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city: string;
  region?: string | undefined;
  country: string;
};

/** @internal */
export const BillingAddress$outboundSchema: z.ZodType<
  BillingAddress$Outbound,
  z.ZodTypeDef,
  BillingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string(),
  region: z.string().optional(),
  country: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BillingAddress$ {
  /** @deprecated use `BillingAddress$inboundSchema` instead. */
  export const inboundSchema = BillingAddress$inboundSchema;
  /** @deprecated use `BillingAddress$outboundSchema` instead. */
  export const outboundSchema = BillingAddress$outboundSchema;
  /** @deprecated use `BillingAddress$Outbound` instead. */
  export type Outbound = BillingAddress$Outbound;
}

/** @internal */
export const ShippingAddress$inboundSchema: z.ZodType<
  ShippingAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string(),
  region: z.string().optional(),
  country: z.string(),
});

/** @internal */
export type ShippingAddress$Outbound = {
  title?: string | undefined;
  givenName?: string | undefined;
  familyName?: string | undefined;
  organizationName?: string | undefined;
  streetAndNumber: string;
  streetAdditional?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  city: string;
  region?: string | undefined;
  country: string;
};

/** @internal */
export const ShippingAddress$outboundSchema: z.ZodType<
  ShippingAddress$Outbound,
  z.ZodTypeDef,
  ShippingAddress
> = z.object({
  title: z.string().optional(),
  givenName: z.string().optional(),
  familyName: z.string().optional(),
  organizationName: z.string().optional(),
  streetAndNumber: z.string(),
  streetAdditional: z.string().optional(),
  postalCode: z.string().optional(),
  email: z.string().optional(),
  phone: z.string().optional(),
  city: z.string(),
  region: z.string().optional(),
  country: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ShippingAddress$ {
  /** @deprecated use `ShippingAddress$inboundSchema` instead. */
  export const inboundSchema = ShippingAddress$inboundSchema;
  /** @deprecated use `ShippingAddress$outboundSchema` instead. */
  export const outboundSchema = ShippingAddress$outboundSchema;
  /** @deprecated use `ShippingAddress$Outbound` instead. */
  export type Outbound = ShippingAddress$Outbound;
}

/** @internal */
export const CreatePaymentAmount$inboundSchema: z.ZodType<
  CreatePaymentAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentAmount$outboundSchema: z.ZodType<
  CreatePaymentAmount$Outbound,
  z.ZodTypeDef,
  CreatePaymentAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentAmount$ {
  /** @deprecated use `CreatePaymentAmount$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentAmount$inboundSchema;
  /** @deprecated use `CreatePaymentAmount$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentAmount$outboundSchema;
  /** @deprecated use `CreatePaymentAmount$Outbound` instead. */
  export type Outbound = CreatePaymentAmount$Outbound;
}

/** @internal */
export const ApplicationFee$inboundSchema: z.ZodType<
  ApplicationFee,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.lazy(() => CreatePaymentAmount$inboundSchema).optional(),
  description: z.string().optional(),
});

/** @internal */
export type ApplicationFee$Outbound = {
  amount?: CreatePaymentAmount$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const ApplicationFee$outboundSchema: z.ZodType<
  ApplicationFee$Outbound,
  z.ZodTypeDef,
  ApplicationFee
> = z.object({
  amount: z.lazy(() => CreatePaymentAmount$outboundSchema).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ApplicationFee$ {
  /** @deprecated use `ApplicationFee$inboundSchema` instead. */
  export const inboundSchema = ApplicationFee$inboundSchema;
  /** @deprecated use `ApplicationFee$outboundSchema` instead. */
  export const outboundSchema = ApplicationFee$outboundSchema;
  /** @deprecated use `ApplicationFee$Outbound` instead. */
  export type Outbound = ApplicationFee$Outbound;
}

/** @internal */
export const CreatePaymentPaymentsAPIAmount$inboundSchema: z.ZodType<
  CreatePaymentPaymentsAPIAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/** @internal */
export type CreatePaymentPaymentsAPIAmount$Outbound = {
  currency: string;
  value: string;
};

/** @internal */
export const CreatePaymentPaymentsAPIAmount$outboundSchema: z.ZodType<
  CreatePaymentPaymentsAPIAmount$Outbound,
  z.ZodTypeDef,
  CreatePaymentPaymentsAPIAmount
> = z.object({
  currency: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentPaymentsAPIAmount$ {
  /** @deprecated use `CreatePaymentPaymentsAPIAmount$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentPaymentsAPIAmount$inboundSchema;
  /** @deprecated use `CreatePaymentPaymentsAPIAmount$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentPaymentsAPIAmount$outboundSchema;
  /** @deprecated use `CreatePaymentPaymentsAPIAmount$Outbound` instead. */
  export type Outbound = CreatePaymentPaymentsAPIAmount$Outbound;
}

/** @internal */
export const Destination$inboundSchema: z.ZodType<
  Destination,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().optional(),
  organizationId: z.string().optional(),
});

/** @internal */
export type Destination$Outbound = {
  type?: string | undefined;
  organizationId?: string | undefined;
};

/** @internal */
export const Destination$outboundSchema: z.ZodType<
  Destination$Outbound,
  z.ZodTypeDef,
  Destination
> = z.object({
  type: z.string().optional(),
  organizationId: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Destination$ {
  /** @deprecated use `Destination$inboundSchema` instead. */
  export const inboundSchema = Destination$inboundSchema;
  /** @deprecated use `Destination$outboundSchema` instead. */
  export const outboundSchema = Destination$outboundSchema;
  /** @deprecated use `Destination$Outbound` instead. */
  export type Outbound = Destination$Outbound;
}

/** @internal */
export const Routing$inboundSchema: z.ZodType<Routing, z.ZodTypeDef, unknown> =
  z.object({
    amount: z.lazy(() => CreatePaymentPaymentsAPIAmount$inboundSchema)
      .optional(),
    destination: z.lazy(() => Destination$inboundSchema).optional(),
    releaseDate: z.string().optional(),
  });

/** @internal */
export type Routing$Outbound = {
  amount?: CreatePaymentPaymentsAPIAmount$Outbound | undefined;
  destination?: Destination$Outbound | undefined;
  releaseDate?: string | undefined;
};

/** @internal */
export const Routing$outboundSchema: z.ZodType<
  Routing$Outbound,
  z.ZodTypeDef,
  Routing
> = z.object({
  amount: z.lazy(() => CreatePaymentPaymentsAPIAmount$outboundSchema)
    .optional(),
  destination: z.lazy(() => Destination$outboundSchema).optional(),
  releaseDate: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Routing$ {
  /** @deprecated use `Routing$inboundSchema` instead. */
  export const inboundSchema = Routing$inboundSchema;
  /** @deprecated use `Routing$outboundSchema` instead. */
  export const outboundSchema = Routing$outboundSchema;
  /** @deprecated use `Routing$Outbound` instead. */
  export type Outbound = Routing$Outbound;
}

/** @internal */
export const CreatePaymentRequestBody$inboundSchema: z.ZodType<
  CreatePaymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string(),
  amount: z.lazy(() => Amount$inboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => Lines$inboundSchema))).optional(),
  billingAddress: z.lazy(() => BillingAddress$inboundSchema).optional(),
  shippingAddress: z.lazy(() => ShippingAddress$inboundSchema).optional(),
  locale: z.nullable(z.string()).optional(),
  method: z.nullable(z.string()).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.string()).optional(),
  captureMode: z.nullable(z.string().default("automatic")),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.lazy(() => ApplicationFee$inboundSchema).optional(),
  routing: z.nullable(z.array(z.lazy(() => Routing$inboundSchema))).optional(),
  sequenceType: z.nullable(z.string().default("oneoff")),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type CreatePaymentRequestBody$Outbound = {
  description: string;
  amount: Amount$Outbound;
  redirectUrl: string | null;
  cancelUrl?: string | null | undefined;
  webhookUrl?: string | null | undefined;
  lines?: Array<Lines$Outbound> | null | undefined;
  billingAddress?: BillingAddress$Outbound | undefined;
  shippingAddress?: ShippingAddress$Outbound | undefined;
  locale?: string | null | undefined;
  method?: string | null | undefined;
  issuer?: string | null | undefined;
  restrictPaymentMethodsToCountry?: string | null | undefined;
  metadata?: string | null | undefined;
  captureMode: string | null;
  captureDelay?: string | null | undefined;
  applicationFee?: ApplicationFee$Outbound | undefined;
  routing?: Array<Routing$Outbound> | null | undefined;
  sequenceType: string | null;
  mandateId?: string | null | undefined;
  customerId?: string | null | undefined;
  profileId?: string | null | undefined;
  testmode: boolean | null;
};

/** @internal */
export const CreatePaymentRequestBody$outboundSchema: z.ZodType<
  CreatePaymentRequestBody$Outbound,
  z.ZodTypeDef,
  CreatePaymentRequestBody
> = z.object({
  description: z.string(),
  amount: z.lazy(() => Amount$outboundSchema),
  redirectUrl: z.nullable(z.string()),
  cancelUrl: z.nullable(z.string()).optional(),
  webhookUrl: z.nullable(z.string()).optional(),
  lines: z.nullable(z.array(z.lazy(() => Lines$outboundSchema))).optional(),
  billingAddress: z.lazy(() => BillingAddress$outboundSchema).optional(),
  shippingAddress: z.lazy(() => ShippingAddress$outboundSchema).optional(),
  locale: z.nullable(z.string()).optional(),
  method: z.nullable(z.string()).optional(),
  issuer: z.nullable(z.string()).optional(),
  restrictPaymentMethodsToCountry: z.nullable(z.string()).optional(),
  metadata: z.nullable(z.string()).optional(),
  captureMode: z.nullable(z.string().default("automatic")),
  captureDelay: z.nullable(z.string()).optional(),
  applicationFee: z.lazy(() => ApplicationFee$outboundSchema).optional(),
  routing: z.nullable(z.array(z.lazy(() => Routing$outboundSchema))).optional(),
  sequenceType: z.nullable(z.string().default("oneoff")),
  mandateId: z.nullable(z.string()).optional(),
  customerId: z.nullable(z.string()).optional(),
  profileId: z.nullable(z.string()).optional(),
  testmode: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRequestBody$ {
  /** @deprecated use `CreatePaymentRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRequestBody$inboundSchema;
  /** @deprecated use `CreatePaymentRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRequestBody$outboundSchema;
  /** @deprecated use `CreatePaymentRequestBody$Outbound` instead. */
  export type Outbound = CreatePaymentRequestBody$Outbound;
}

/** @internal */
export const CreatePaymentRequest$inboundSchema: z.ZodType<
  CreatePaymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  include: z.nullable(z.string()).optional(),
  RequestBody: z.lazy(() => CreatePaymentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreatePaymentRequest$Outbound = {
  include?: string | null | undefined;
  RequestBody?: CreatePaymentRequestBody$Outbound | undefined;
};

/** @internal */
export const CreatePaymentRequest$outboundSchema: z.ZodType<
  CreatePaymentRequest$Outbound,
  z.ZodTypeDef,
  CreatePaymentRequest
> = z.object({
  include: z.nullable(z.string()).optional(),
  requestBody: z.lazy(() => CreatePaymentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreatePaymentRequest$ {
  /** @deprecated use `CreatePaymentRequest$inboundSchema` instead. */
  export const inboundSchema = CreatePaymentRequest$inboundSchema;
  /** @deprecated use `CreatePaymentRequest$outboundSchema` instead. */
  export const outboundSchema = CreatePaymentRequest$outboundSchema;
  /** @deprecated use `CreatePaymentRequest$Outbound` instead. */
  export type Outbound = CreatePaymentRequest$Outbound;
}
